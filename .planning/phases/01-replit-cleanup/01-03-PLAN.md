---
phase: 01-replit-cleanup
plan: 03
type: execute
wave: 2
depends_on: ["01-01", "01-02"]
files_modified:
  - server/objectStorage.ts
  - server/objectAcl.ts
  - server/routes.ts
  - server/giftCards/routes.ts
  - server/index.ts
  - client/src/components/ObjectUploader.tsx
  - client/src/components/CommunicationsDashboard.tsx
  - package.json
  - .env.example
  - shared/schema.ts

autonomous: true

user_setup:
  - service: vercel-blob
    why: "File storage replacing GCS sidecar"
    env_vars:
      - name: BLOB_READ_WRITE_TOKEN
        source: "Vercel Dashboard -> Storage -> Blob -> Create Store -> Tokens tab -> copy read-write token"

must_haves:
  truths:
    - "File upload (via ObjectUploader component) works using Vercel Blob — client POSTs file to server, server puts to Blob, returns URL"
    - "Gift card theme image upload uses Vercel Blob put() with access: 'public'"
    - "Private file download streams from Vercel Blob through Express proxy with owner/visibility ACL check"
    - "No GCS sidecar references (127.0.0.1:1106) remain in the codebase"
    - "No @google-cloud/storage package in package.json"
    - ".env.example lists all required and optional env vars"
    - "Server validates required env vars at startup and fails fast if missing"
  artifacts:
    - path: "server/objectStorage.ts"
      provides: "Vercel Blob storage service replacing GCS sidecar"
      exports: ["ObjectStorageService", "ObjectNotFoundError"]
    - path: "server/objectAcl.ts"
      provides: "Database-backed ACL with owner and visibility fields"
      exports: ["ObjectAclPolicy", "ObjectPermission", "canAccessObject", "getObjectAclPolicy", "setObjectAclPolicy"]
    - path: ".env.example"
      provides: "Environment variable reference for local development"
    - path: "shared/schema.ts"
      provides: "blobAclPolicies table for ACL storage"
      contains: "blobAclPolicies"
  key_links:
    - from: "server/objectStorage.ts"
      to: "@vercel/blob"
      via: "put, get, del imports"
      pattern: "from '@vercel/blob'"
    - from: "server/objectAcl.ts"
      to: "shared/schema.ts"
      via: "blobAclPolicies table for ACL storage"
      pattern: "blobAclPolicies"
    - from: "client/src/components/ObjectUploader.tsx"
      to: "server/routes.ts"
      via: "POST /api/objects/upload endpoint"
      pattern: "/api/objects/upload"
    - from: "server/giftCards/routes.ts"
      to: "@vercel/blob"
      via: "put() for public image upload"
      pattern: "put\\("
---

<objective>
Replace the GCS sidecar storage system with Vercel Blob, migrate the object ACL system from GCS metadata to a database table, update all file upload/download flows, add startup env var validation, and create .env.example.

Purpose: Complete the storage migration from Replit's GCS sidecar to Vercel Blob. After this plan, the entire codebase is free of Replit dependencies and can run locally or on Vercel with standard environment variables.
Output: Vercel Blob-backed file storage, database-backed ACL, env var validation, .env.example reference file.
</objective>

<execution_context>
@/Users/jeremygill/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jeremygill/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-replit-cleanup/01-RESEARCH.md
@.planning/phases/01-replit-cleanup/01-01-SUMMARY.md
@.planning/phases/01-replit-cleanup/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add blobAclPolicies schema, rewrite objectAcl.ts and objectStorage.ts for Vercel Blob</name>
  <files>shared/schema.ts, server/objectAcl.ts, server/objectStorage.ts, package.json</files>
  <action>
**1. Install @vercel/blob and remove @google-cloud/storage:**
```bash
npm install @vercel/blob
npm uninstall @google-cloud/storage
```

**2. Add blobAclPolicies table to shared/schema.ts:**

Add near the other table definitions:
```typescript
export const blobAclPolicies = pgTable("blob_acl_policies", {
  pathname: text("pathname").primaryKey(),
  ownerId: text("owner_id").notNull(),
  visibility: text("visibility").notNull().default("private"), // "public" or "private"
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});
```

Also export insert/select types:
```typescript
export type BlobAclPolicy = typeof blobAclPolicies.$inferSelect;
export type InsertBlobAclPolicy = typeof blobAclPolicies.$inferInsert;
```

Run `npm run db:push` to sync the new table to the database.

**3. Rewrite server/objectAcl.ts** — replace the entire file. Remove all `@google-cloud/storage` imports. The new implementation uses database queries instead of GCS object metadata:

```typescript
import { db } from "./db";
import { blobAclPolicies } from "../shared/schema";
import { eq } from "drizzle-orm";

export enum ObjectPermission {
  READ = "read",
  WRITE = "write",
}

export interface ObjectAclPolicy {
  owner: string;
  visibility: "public" | "private";
}

export async function setObjectAclPolicy(
  pathname: string,
  aclPolicy: ObjectAclPolicy,
): Promise<void> {
  await db
    .insert(blobAclPolicies)
    .values({
      pathname,
      ownerId: aclPolicy.owner,
      visibility: aclPolicy.visibility,
      updatedAt: new Date(),
    })
    .onConflictDoUpdate({
      target: blobAclPolicies.pathname,
      set: {
        ownerId: aclPolicy.owner,
        visibility: aclPolicy.visibility,
        updatedAt: new Date(),
      },
    });
}

export async function getObjectAclPolicy(
  pathname: string,
): Promise<ObjectAclPolicy | null> {
  const rows = await db
    .select()
    .from(blobAclPolicies)
    .where(eq(blobAclPolicies.pathname, pathname))
    .limit(1);

  if (rows.length === 0) return null;
  return { owner: rows[0].ownerId, visibility: rows[0].visibility as "public" | "private" };
}

export async function deleteObjectAclPolicy(
  pathname: string,
): Promise<void> {
  await db.delete(blobAclPolicies).where(eq(blobAclPolicies.pathname, pathname));
}

export async function canAccessObject({
  userId,
  pathname,
  requestedPermission,
}: {
  userId?: string;
  pathname: string;
  requestedPermission: ObjectPermission;
}): Promise<boolean> {
  const aclPolicy = await getObjectAclPolicy(pathname);
  if (!aclPolicy) return false;

  // Public objects are always accessible for read
  if (aclPolicy.visibility === "public" && requestedPermission === ObjectPermission.READ) {
    return true;
  }

  // Access control requires user id
  if (!userId) return false;

  // Owner can always access
  if (aclPolicy.owner === userId) return true;

  return false;
}
```

Note: The `aclRules` array is removed entirely — the research confirmed `ObjectAccessGroupType` enum was empty and no group-based rules were ever implemented. The ACL is simplified to owner + visibility only.

**4. Rewrite server/objectStorage.ts** — replace the entire file. Remove ALL `@google-cloud/storage` imports and the Replit sidecar endpoint. Use `@vercel/blob` instead:

```typescript
import { put, get, del } from '@vercel/blob';
import { Response } from "express";
import { Readable } from "node:stream";
import { randomUUID } from "crypto";
import {
  ObjectAclPolicy,
  ObjectPermission,
  canAccessObject,
  getObjectAclPolicy,
  setObjectAclPolicy,
  deleteObjectAclPolicy,
} from "./objectAcl";

export { ObjectAclPolicy, ObjectPermission };

export class ObjectNotFoundError extends Error {
  constructor() {
    super("Object not found");
    this.name = "ObjectNotFoundError";
    Object.setPrototypeOf(this, ObjectNotFoundError.prototype);
  }
}

export class ObjectStorageService {
  constructor() {}

  // Upload a file buffer to Vercel Blob (server-side upload).
  async uploadObject(
    pathname: string,
    buffer: Buffer,
    contentType: string,
    access: 'public' | 'private' = 'private',
  ): Promise<{ url: string; pathname: string }> {
    const blob = await put(pathname, buffer, {
      access,
      contentType,
      addRandomSuffix: false,
    });
    return { url: blob.url, pathname };
  }

  // Download an object and stream it to the Express response.
  async downloadObject(
    blobUrl: string,
    res: Response,
    cacheTtlSec: number = 3600,
  ): Promise<void> {
    try {
      const response = await fetch(blobUrl);
      if (!response.ok || !response.body) {
        if (!res.headersSent) {
          res.status(404).json({ error: "Object not found" });
        }
        return;
      }

      const contentType = response.headers.get('content-type') || 'application/octet-stream';
      const contentLength = response.headers.get('content-length');

      res.set({
        'Content-Type': contentType,
        ...(contentLength ? { 'Content-Length': contentLength } : {}),
        'Cache-Control': `private, max-age=${cacheTtlSec}`,
      });

      Readable.fromWeb(response.body as any).pipe(res);
    } catch (error) {
      console.error("Error downloading file:", error);
      if (!res.headersSent) {
        res.status(500).json({ error: "Error downloading file" });
      }
    }
  }

  // Upload a file and return the blob URL (for ObjectUploader flow).
  // Client POSTs file to Express, Express puts to Vercel Blob.
  async uploadEntityObject(
    buffer: Buffer,
    contentType: string,
    originalName?: string,
  ): Promise<{ url: string; pathname: string }> {
    const ext = originalName ? originalName.split('.').pop() : 'bin';
    const pathname = `uploads/${randomUUID()}.${ext}`;
    return this.uploadObject(pathname, buffer, contentType, 'private');
  }

  // Set ACL policy on a blob by its pathname.
  async trySetObjectEntityAclPolicy(
    blobUrl: string,
    aclPolicy: ObjectAclPolicy,
  ): Promise<string> {
    // Extract pathname from blob URL or use as-is if already a pathname
    const pathname = this.extractPathname(blobUrl);
    await setObjectAclPolicy(pathname, aclPolicy);
    return pathname;
  }

  // Check if user can access a blob by its pathname.
  async canAccessObjectEntity({
    userId,
    pathname,
    requestedPermission,
  }: {
    userId?: string;
    pathname: string;
    requestedPermission?: ObjectPermission;
  }): Promise<boolean> {
    return canAccessObject({
      userId,
      pathname,
      requestedPermission: requestedPermission ?? ObjectPermission.READ,
    });
  }

  // Delete a blob and its ACL policy.
  async deleteObject(blobUrl: string): Promise<void> {
    await del(blobUrl);
    const pathname = this.extractPathname(blobUrl);
    await deleteObjectAclPolicy(pathname);
  }

  // Extract a pathname from a Vercel Blob URL for ACL lookups.
  private extractPathname(blobUrlOrPath: string): string {
    if (blobUrlOrPath.startsWith('http')) {
      try {
        const url = new URL(blobUrlOrPath);
        // Vercel Blob URLs have the pathname after the domain
        return url.pathname.slice(1); // remove leading /
      } catch {
        return blobUrlOrPath;
      }
    }
    return blobUrlOrPath;
  }
}
```

Key design decisions:
- No more `objectStorageClient` export (was GCS Storage instance). Gift cards and routes must use `ObjectStorageService` methods.
- No more `getPublicObjectSearchPaths()` or `getPrivateObjectDir()` — Vercel Blob doesn't use bucket/path env vars.
- No more `searchPublicObject()` — replaced by direct URL access for public blobs.
- No more `getObjectEntityUploadURL()` (presigned URL) — replaced by server-side `uploadEntityObject()`.
- No more `getObjectEntityFile()` — replaced by direct URL-based `get()`.
- No more `normalizeObjectEntityPath()` — blob URLs are stored directly.
- `signObjectURL()` removed entirely (was sidecar-based).
  </action>
  <verify>
1. `npm run check` — TypeScript compiles with no errors
2. `grep -rn "google-cloud/storage\|REPLIT_SIDECAR\|127.0.0.1:1106\|objectStorageClient" server/` — returns no matches
3. `grep "google-cloud" package.json` — returns no matches
4. `npm run db:push` — schema sync succeeds (blobAclPolicies table created)
  </verify>
  <done>objectStorage.ts uses Vercel Blob (put, get, del). objectAcl.ts uses database table. @google-cloud/storage removed. No GCS or sidecar references remain.</done>
</task>

<task type="auto">
  <name>Task 2: Update all callers — routes.ts, giftCards, ObjectUploader, CommunicationsDashboard — and add startup validation + .env.example</name>
  <files>server/routes.ts, server/giftCards/routes.ts, server/index.ts, client/src/components/ObjectUploader.tsx, client/src/components/CommunicationsDashboard.tsx, .env.example</files>
  <action>
**1. Update server/routes.ts object storage endpoints:**

The following sections reference GCS and must be updated:

**a. Lines 12-13 imports:** Update imports from objectStorage and objectAcl:
```typescript
import { ObjectStorageService, ObjectNotFoundError } from "./objectStorage";
import { ObjectPermission } from "./objectAcl";
```
These imports stay the same but the underlying module changed.

**b. Lines ~3444-3470 — Object download and upload endpoints:**

The object download endpoint (`GET /objects/*`) currently creates `ObjectStorageService`, calls `getObjectEntityFile()` and `canAccessObjectEntity()` and `downloadObject()`. Rewrite to work with Vercel Blob URLs:

The download endpoint must change approach. Previously it used GCS file objects. Now it needs to:
1. Look up the blob URL from the ACL database (the pathname stored as ACL key maps to the blob URL)
2. Check access via `canAccessObjectEntity()`
3. Stream via `downloadObject(blobUrl, res)`

Since we're changing the storage model, the download route should accept the blob pathname and look up the stored URL. Simplest approach: store the full Vercel Blob URL in the database ACL table or in the relevant entity (waiver, course image). The proxy route then fetches from that URL.

Update the download route pattern:
```typescript
// GET /objects/:objectPath(*) — proxy download for private objects
app.get('/objects/:objectPath(*)', isAuthenticated, async (req: any, res) => {
  try {
    const objectPath = req.params.objectPath;
    const objectStorageService = new ObjectStorageService();

    const canAccess = await objectStorageService.canAccessObjectEntity({
      userId: req.user?.id?.toString(),
      pathname: objectPath,
      requestedPermission: ObjectPermission.READ,
    });

    if (!canAccess) {
      return res.status(403).json({ error: "Access denied" });
    }

    // The objectPath is used to look up the blob URL from the ACL record
    // or it can be the full Vercel Blob URL stored in the database
    // For now, construct the Vercel Blob store URL
    const blobUrl = `https://${process.env.BLOB_READ_WRITE_TOKEN?.split('_')[0] || 'blob'}.public.blob.vercel-storage.com/${objectPath}`;

    await objectStorageService.downloadObject(blobUrl, res);
  } catch (error: any) {
    if (error instanceof ObjectNotFoundError) {
      return res.status(404).json({ error: "Object not found" });
    }
    console.error("Error serving object:", error);
    res.status(500).json({ error: "Error serving file" });
  }
});
```

Actually, a better approach: store the full Vercel Blob URL in the `blobAclPolicies` table as an additional column, or simply fetch the blob by its pathname using the Vercel Blob SDK. Let me revise — add a `blobUrl` column to the schema and use it.

**REVISED approach for download:** Add a `blob_url` column to `blobAclPolicies` in shared/schema.ts:
```typescript
blobUrl: text("blob_url").notNull(),
```
Then update objectAcl.ts `setObjectAclPolicy` to also store the blobUrl, and add a `getBlobUrl(pathname)` function. The download route looks up the URL from the database.

Update the `ObjectAclPolicy` interface to include `blobUrl`:
```typescript
export interface ObjectAclPolicy {
  owner: string;
  visibility: "public" | "private";
  blobUrl?: string;
}
```

And the `setObjectAclPolicy` and `getObjectAclPolicy` functions to handle it.

Then the download route becomes:
```typescript
app.get('/objects/:objectPath(*)', isAuthenticated, async (req: any, res) => {
  try {
    const objectPath = req.params.objectPath;
    const objectStorageService = new ObjectStorageService();

    const canAccess = await objectStorageService.canAccessObjectEntity({
      userId: req.user?.id?.toString(),
      pathname: objectPath,
    });
    if (!canAccess) {
      return res.status(403).json({ error: "Access denied" });
    }

    const aclPolicy = await getObjectAclPolicy(objectPath);
    if (!aclPolicy?.blobUrl) {
      return res.status(404).json({ error: "Object not found" });
    }

    await objectStorageService.downloadObject(aclPolicy.blobUrl, res);
  } catch (error: any) {
    console.error("Error serving object:", error);
    res.status(500).json({ error: "Error serving file" });
  }
});
```

**c. Lines ~3469-3478 — Upload endpoint:**
Replace the presigned URL approach with server-side upload:
```typescript
app.post('/api/objects/upload', isAuthenticated, upload.single('file'), async (req: any, res) => {
  try {
    if (!req.file) return res.status(400).json({ error: 'No file provided' });
    const objectStorageService = new ObjectStorageService();
    const result = await objectStorageService.uploadEntityObject(
      req.file.buffer,
      req.file.mimetype,
      req.file.originalname,
    );
    res.json({ uploadURL: result.url, pathname: result.pathname });
  } catch (error: any) {
    console.error("Error uploading file:", error);
    res.status(500).json({ error: "Error uploading file" });
  }
});
```

Make sure `multer` with `memoryStorage` is configured for this route. Check if there's already a multer instance in routes.ts; if not, add:
```typescript
import multer from 'multer';
const upload = multer({ storage: multer.memoryStorage(), limits: { fileSize: 15 * 1024 * 1024 } });
```

**d. Lines ~4248-4412 — trySetObjectEntityAclPolicy calls:**
These three calls set ACL on uploaded objects. Update them to pass the blob URL:
```typescript
const objectStorageService = new ObjectStorageService();
const objectPath = await objectStorageService.trySetObjectEntityAclPolicy(
  rawPath, // the blob URL returned from upload
  { owner: userId.toString(), visibility: 'private', blobUrl: rawPath }
);
```

**e. Lines ~8917-8962 — /api/object-storage/upload-url endpoint:**
This endpoint currently uses the Replit sidecar to generate a signed URL. Replace it entirely with the same server-side upload approach. If the endpoint is called from `CommunicationsDashboard.tsx` as a POST expecting a `{ url }` response, update it to accept a file upload:

```typescript
app.post('/api/object-storage/upload-url', isAuthenticated, upload.single('file'), async (req: any, res) => {
  try {
    if (!req.file) return res.status(400).json({ error: 'No file provided' });
    const objectStorageService = new ObjectStorageService();
    const result = await objectStorageService.uploadEntityObject(
      req.file.buffer,
      req.file.mimetype,
      req.file.originalname,
    );
    // Set ACL for the uploaded file
    await objectStorageService.trySetObjectEntityAclPolicy(
      result.url,
      { owner: req.user.id.toString(), visibility: 'private', blobUrl: result.url }
    );
    res.json({ url: result.url, pathname: result.pathname });
  } catch (error: any) {
    console.error("Error uploading file:", error);
    res.status(500).json({ error: "Error uploading file" });
  }
});
```

**2. Update server/giftCards/routes.ts:**
Remove `import { objectStorageClient } from '../objectStorage'` and replace GCS bucket operations with Vercel Blob:

For gift card theme image uploads (around lines 400-460), replace:
```typescript
const bucket = objectStorageClient.bucket(bucketName);
const file = bucket.file(objectName);
await file.save(req.file.buffer, { contentType: req.file.mimetype });
```
With:
```typescript
import { put } from '@vercel/blob';
// ... inside the route handler:
const blob = await put(
  `gift-card-themes/${randomUUID()}.${finalExt}`,
  req.file.buffer,
  { access: 'public', contentType: req.file.mimetype, addRandomSuffix: false }
);
// Store blob.url in the database instead of the old GCS path
```

For gift card theme image deletion (if exists), replace GCS delete with:
```typescript
import { del } from '@vercel/blob';
await del(blobUrl);
```

**3. Update client/src/components/ObjectUploader.tsx:**
The component currently calls `onGetUploadParameters()` to get a presigned PUT URL, then does a `fetch(url, { method: 'PUT', body: file })`. Change it to POST the file directly to the server:

Update `ObjectUploader` to use FormData and POST to the server endpoint instead of a presigned PUT URL. The `onGetUploadParameters` prop should be replaced with a simpler `uploadEndpoint` prop or inline logic:

```typescript
// Instead of getting a presigned URL and doing a PUT:
const formData = new FormData();
formData.append('file', file);
const response = await fetch('/api/objects/upload', {
  method: 'POST',
  body: formData,
  credentials: 'include',
});
const data = await response.json();
// data.uploadURL is the blob URL
```

Review all callers of ObjectUploader (CourseCreationForm, EditCourseForm, EventCreationForm, CommunicationsDashboard, product-management) and update the `onGetUploadParameters` / `onUploadComplete` callbacks to match the new flow.

**4. Update client/src/components/CommunicationsDashboard.tsx:**
Lines ~3578-3597 call `/api/object-storage/upload-url` with JSON body. Update to use FormData POST:
```typescript
const formData = new FormData();
formData.append('file', file);
const response = await fetch('/api/object-storage/upload-url', {
  method: 'POST',
  body: formData,
  credentials: 'include',
});
```

**5. Add startup env var validation in server/index.ts:**
Add near the top of the file, before Express app setup:
```typescript
function validateRequiredEnvVars() {
  const required = ['APP_URL', 'DATABASE_URL', 'SESSION_SECRET'];
  const missing = required.filter(key => !process.env[key]);
  if (missing.length > 0) {
    throw new Error(`Missing required environment variables: ${missing.join(', ')}`);
  }
  if (!process.env.STRIPE_SECRET_KEY) {
    console.warn('[Stripe] STRIPE_SECRET_KEY not set - payment endpoints will be disabled');
  }
  if (!process.env.BLOB_READ_WRITE_TOKEN) {
    console.warn('[Blob] BLOB_READ_WRITE_TOKEN not set - file storage will be disabled');
  }
}
validateRequiredEnvVars();
```

**6. Create .env.example** at project root:
```bash
# Required
APP_URL=http://localhost:5000
DATABASE_URL=postgresql://user:password@host:5432/dbname
SESSION_SECRET=your-session-secret-here

# Stripe (optional — server starts without, payments disabled)
STRIPE_SECRET_KEY=sk_test_...
VITE_STRIPE_PUBLIC_KEY=pk_test_...

# Vercel Blob Storage (optional — server starts without, file storage disabled)
BLOB_READ_WRITE_TOKEN=vercel_blob_rw_...

# Email (SendGrid)
SENDGRID_API_KEY=SG....

# SMS (Twilio)
TWILIO_ACCOUNT_SID=AC...
TWILIO_AUTH_TOKEN=...
TWILIO_PHONE_NUMBER=+1...

# Google Calendar OAuth
GOOGLE_SERVICE_ACCOUNT_KEY={"type":"service_account",...}
INTERNAL_API_KEY=your-internal-api-key

# Encryption (optional — enables encrypted data storage)
ENCRYPTION_MASTER_KEY=your-32-byte-hex-key

# Integrations
PRINTIFY_API_KEY=...
MOODLE_TOKEN=...
```
  </action>
  <verify>
Run these checks:
1. `npm run check` — TypeScript compiles with no errors
2. `npm run build` — builds successfully
3. `grep -rn "google-cloud\|REPLIT_SIDECAR\|127.0.0.1:1106\|objectStorageClient\|REPL_ID\|REPLIT_" server/ client/src/ --include="*.ts" --include="*.tsx"` — returns no matches
4. `grep "google-cloud" package.json` — returns no matches
5. Verify `.env.example` exists at project root
6. Verify `blobAclPolicies` table definition exists in shared/schema.ts
  </verify>
  <done>All file upload/download flows use Vercel Blob. Gift card images uploaded with public access. Private files served through Express proxy with database ACL check. No GCS or Replit sidecar references remain anywhere in the codebase. .env.example created. Startup validation added.</done>
</task>

</tasks>

<verification>
1. `npm run build` completes without error
2. `npm run check` passes with no TypeScript errors
3. `grep -rn "REPLIT\|REPL_ID\|google-cloud\|127.0.0.1:1106\|sidecar" server/ client/src/ --include="*.ts" --include="*.tsx"` — returns zero matches
4. No `@google-cloud/storage` in package.json
5. `@vercel/blob` present in package.json dependencies
6. `.env.example` exists with all required vars documented
7. `blobAclPolicies` table exists in shared/schema.ts
8. Server startup validates APP_URL, DATABASE_URL, SESSION_SECRET
</verification>

<success_criteria>
File upload and signed URL generation use native Vercel Blob SDK. Gift card theme images upload with public access. Private objects served via Express proxy with database-backed ACL. No GCS, no sidecar, no Replit references remain in the entire codebase. The server starts locally with standard env vars. `npm run build` and `npm run check` both pass.
</success_criteria>

<output>
After completion, create `.planning/phases/01-replit-cleanup/01-03-SUMMARY.md`
</output>
